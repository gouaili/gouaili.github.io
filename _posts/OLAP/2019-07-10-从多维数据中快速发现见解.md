

背景：

     随着用户对自动发现洞察见解的需求不断增加，发现有趣的数据模型(观点或见解)是数据中常见且重要的分析需求。然而，从多维数据中自动发现有趣的模型仍然具有挑战性。对于不同的模型类型，缺乏统一的公式，以及用于有效和高效地发现它们的一般挖掘框架。由此提出了一种快速洞察，快速自动地从多维数据中发现有趣的模式的新技术，这些有趣的模式包括相关性、异常、趋势等。

       手动进行数据探索是灵活的，但是对于时间有限、技能有限的非专家用户，需要能够快速迭代地创建和优化可视化来探查有趣和见解。为了加快数据探索过程，我们可以通过自动推荐有趣的数据模型来补充交互式可视化探索工具。当模型自动从数据中挖掘出来并以可视化的形式呈现给用户时，用户可以从他们身上开始而不是从零开始探索。

目的：

本篇文章的主要内容：

• 提出了一个有趣模式的统一表达式，称为对多维数据集的洞察力。

• 构建了一个洞察挖掘框架，使用两种关键技术来实现高效的洞察挖掘性能：

       最佳优先搜索机制来优先考虑洞察评估任务，以及智能查询分组来减少查询数量。

• 设计了一种洞察评估算法，以消除EII（Easily Inferable Insights），从而获得高质量的洞察结果。

•  评估QuickInsights并验证其发现洞察力的有效性和效率，QuickInsights在Microsoft Power BI中发布。

挑战：

质量挑战：用户可以基于当前的数据模型信息轻易地推断出一些见解。 但是它们提供的信息量很少，用户不那么感兴趣。 例如，多年来两个度量值的几乎完美的线性相关，其中measure1是以美元计的销售额，而measure2是以欧元计算的销售额（即，仅根据汇率而不同）。 我们试图避免这种易于理解的洞察（简称EII），以保证高质量的洞察挖掘结果。 如何有效地检测和消除EII对洞察力挖掘提出了挑战。

效率挑战：随着维数的增加，挖掘多维数据集的搜索空间呈指数增长。 此外，由于QuickInsights主要用于交互式数据探索，因此必须在短时间预算内输出见解。 为了有效地利用时间预算，我们应该首先尝试探索存在高质量见解的“最佳”可能数据子集。 此外，洞察力评估总是涉及针对数据库的大量数据聚合查询，这可能进一步影响挖掘性能。

2. 洞察力建模

2.1 数据模型

        一个多维数据表，由维度和度量组成。表1显示了有关平板电脑销售的多维数据集的一些样本数据。维度用于分组或过滤记录。维度的值是类目类型的（例如，“国家”）或序数（例如，“年”）。度量是可以在其上执行某些聚合（例如，SUM，AVG）的数字列（例如，“Sales”）。形式上，给定多维数据集 R（𝒟，M），其中𝒟= {𝐷1，...𝐷𝑑} 是维度的集合，M是度量的集合。设𝑑𝑜𝑚（𝐷𝑖）为domain的值域。

           子空间。子空间定义为过滤器的大小d集合𝑠= {𝑠[1]，...，𝑠[𝑑]}，其中𝑠[𝑖]∈𝑑𝑜𝑚（𝐷𝑖）∪{*}，'*'指到“任何”的价值。为简洁起见，我们使用星号（'*'）隐藏过滤器。我们称子维空间𝑠具有维数𝑙：=| {𝑠[𝑖] |𝑠[𝑖]∈𝑠，𝑠[𝑖]≠*} | 。每个子空间与每个度量的聚合值相关联，例如，{Country：China}是一个子空间，其中𝑙= 1，其对应的度量Sales聚合由SUM聚合。为简明扼要，我们将{Country：China}简称为{China}。

           兄弟组 & 分裂（Sibling group & breakdown）。给定子空间s和维度𝐷𝑖，兄弟组定义为𝑆𝐺（𝑠，𝐷𝑖）= {𝑠'|𝑠'[𝑖]≠*，𝑠'[𝑗] =𝑠[𝑗]∀𝑗≠𝑖 }，即一组子空间仅在𝑑𝑜𝑚（𝐷𝑖）的值上不同。在这个设置中，我们称𝐷𝑖分裂维度（即对子空间的分组操作），并且我们表示𝑠⊕𝐷𝑖→𝑆𝐺（𝑠，𝐷𝑖）表示兄弟组𝑆𝐺（𝑠，𝐷𝑖）是从子空间通过分解𝐷𝑖。例如，子空间{2011，China}，...，{2016，China}组成一个兄弟组，因为它们只是维度Year的值不同，而Year是细分维度。

2.2 洞察规则

       在多维数据分析领域，一个有趣的模式一般可以概括为：它从某个角度反映了某个特定数据主题的有趣内容。我们称这种有趣的模式为洞察。以图1中的趋势洞察为例，它的主题包括兄弟组𝑆𝐺({𝐶h𝑖𝑛𝑎}, 𝑌𝑒𝑎𝑟)和度量Sales。它的聚合值形成了一个按年的时间序列，用于趋势分析，这就是这种见解的观点。它的有趣之处体现在“迅速而持续地向上发展”。下面我们将相应地描述一个洞察的主题、视角和趣味性。

2.2.1 洞察主题

我们将洞察主题定义为：

 定义1(洞察主题): Definition 1. 𝑠𝑢𝑏𝑗𝑒𝑐𝑡 ≔ {𝑠𝑢𝑏𝑠𝑝𝑎𝑐𝑒(𝑠), 𝑏𝑟𝑒𝑎𝑘𝑑𝑜𝑤𝑛, 𝑚𝑒𝑎𝑠𝑢𝑟𝑒(𝑠)}

例如，图1中两个洞察的主题分别是：{{*}, ServerName, CPU Usage}, and {{China}, Year,Sales}。

洞察主题指定洞察的内容，它对应于一组或多组聚合值，可用于量化有趣性。为了便于直观理解，可以映射到可视图表。分裂维度(breakdown)的值可以映射到x轴值; 并且聚合值(measure)可以映射到y轴值; 子空间(subspace)可以映射到过滤器。 对于具有多个子空间或多个度量的情况，它们可以映射到具有相同x轴的多个y轴值系列。

2.2.2 洞察类型

我们将不同的观点体现为不同的洞察类型。 例如，洞察类型“Outstanding＃1”对应于找到“显着高于剩余值的主要值”的视角。 指定洞察类型对于进一步量化洞察力的趣味性至关重要。

我们开发了12种洞察类型，对应于实践中常用的12种不同观点，如归因、变化点、相关性、异常值、季节性等。

     类型分类：

          #Type5 洞察类型属于单点洞察类别。单点洞察是指单个子空间和单个度量，并按非序数维分解。

          #Type4 通过使用序数分解维数。从语义上讲是指与时间序列相关。

          #Type3 复合洞察力指的是具有多个子空间或度量的洞察。 具体而言，相关性洞察会比较洞察主题中的两个子空间; 交叉测量相关和2DClustering比较洞察主题中的两个度量。

2.2.3 洞察评分

我们通过给洞察分配一个适当的分数来量化它的“有趣性”。直觉上，洞察的趣味性由两个因素来判断。首先，洞察的主题应该表达了一些重要的东西，例如，我们希望洞察主题成为畅销品牌，或者是一个拥有巨大市场份额而不是被忽视的类别。第二，汇总结果应与基线显示出显著差异。我们将基线表示为一个统计假设，它反映了大多数不用挖掘的一些常见情况（即，具有无趣模式的聚合结果）。本文将这两个因素分别称为影响因素和意义因素，并将其结合起来进行评价。

影响

影响反映了洞察主题对整个数据集的重要性。对影响的价值表示为𝑖𝑚𝑝𝑎𝑐𝑡𝑖 (𝑖𝑛𝑠𝑖𝑔h𝑡. 𝑠𝑢𝑏𝑗𝑒𝑐𝑡) 或简写为𝑖𝑚𝑝𝑎𝑐𝑡𝑖。图2显示了当影响衡量标准是市场份额时，两个不同市场的销售趋势。市场份额越高越重要。 𝑖𝑚𝑝𝑎𝑐𝑡𝑖是反单调的，即如果洞察A的主体是洞察B的主体的超集，那么A的影响应该不小于B的影响。规范化对于影响措施的公平性比较是必要的。于是定义影响评分公式为：𝑖𝑚𝑝𝑎𝑐𝑡𝑖=𝑀𝑜𝑛𝑜𝐴𝑔𝑔𝑟𝑖（𝑖𝑛𝑠𝑖𝑔h𝑡.𝑠𝑢𝑏𝑠𝑝𝑎𝑐𝑒）／𝑀𝑜𝑛𝑜𝐴𝑔𝑔𝑟𝑖 ({∗})，𝑖𝑚𝑝𝑎𝑐𝑡𝑖是在[0,1]范围内的值。我们定义了洞察力的影响衡量标准，则最能显示洞察的影响力的衡量：𝑖𝑚𝑝𝑎𝑐𝑡 = max(𝑖𝑚𝑝𝑎𝑐𝑡𝑖 )

意义

意义是根据洞察主体的聚合值进行评估的，即获得的聚合值相对于基线的重要性。我们将基线表示为一个与洞察类型相关的空假设，它反映了大多数非洞察形成的常见情况，并通过基于显著性的假设检验来量化洞察意义。图2中下面的两个图表显示了两个不同的时间序列信号：左一个比右一个更重要，因为它包含一定的规律，而不是纯噪声。更具体地说，在QuickInsights的场景中，在不进一步了解用户偏好的情况下，我们根据常识为每种类型的洞察力提出基线。这种常识应该近似于可能结果的分布，这些结果是无趣的（即，对于数据分析来说，微不足道或价值较低）。例如，为了计算时间序列实例上是否存在变更点的重要性，合理的基线是假设时间序列相对稳定，符合常识，并且可以很容易地形式化为：𝐻0:𝑓𝑜𝑟 1 ≤ 𝑘 ≤ 𝑁: 𝑝𝜃(𝑦𝑘|𝑦𝑘−1~𝑦1) = 𝑝𝜃0(𝑦𝑘|𝑦𝑘−1~𝑦1)，其中𝑝𝜃0为固定概率分布。洞察重要性取[0，1]内的值。值越接近1，洞察就越重要。

分数 

 通过将这两个因素结合起来，我们得出了最终的分数，它量化了洞察的整体“有趣度”：

定义3（分数）

这里下标t指的是特定的洞察类型，考虑到重要性计算是洞察类型依赖的。 f和g是任何非负的单调函数。 目前，我们采用最简单的形式：

                         𝑠𝑐𝑜𝑟𝑒 𝑡=𝑖𝑚𝑝𝑎𝑐𝑡 ∙ 𝑠𝑖𝑔𝑛𝑖𝑓𝑖𝑐𝑎𝑛𝑐𝑒𝑡

定义4（洞察表示）。 基于上述考虑，我们将洞察表示为

                         𝑖𝑛𝑠𝑖𝑔h𝑡≔{𝑠𝑢𝑏𝑠𝑝𝑎𝑐𝑒（𝑠），𝑏𝑟𝑒𝑎𝑘𝑑𝑜𝑤𝑛，𝑚𝑒𝑎𝑠𝑢𝑟𝑒（𝑠），𝑡𝑦𝑝𝑒，𝑠𝑐𝑜𝑟𝑒}

3.计算架构

 总体而言，QuickInsights旨在实现三个设计目标：（1）是一个有时限的挖掘程序; （2）可移植的商业查询引擎; （3）可扩展以适应新类型的见解。

      1）有时限的挖掘程序。 QuickInsights的典型场景是针对交互式数据探索的场景，因此它必须在给定的有限时间预算内输出见解，例如10秒。为了高效发现洞察见解，数据查询和重要性评估由一组任务并行执行，其中每个任务将子空间（以及每个子空间的相应影响）和细分作为输入，并负责评估出特定类型的洞察，来适用于输入参数（例如，当输入分裂维度是序数时，评估时间序列相关的见解）。

      2）可移植到任意查询引擎。作为一般的挖掘框架，QuickInsights应该是可移植的，以构建在任意查询引擎上，例如SQL数据库，SQL Server Analysis Services等，其中通常存储多维数据集。因此，抽象和通用的查询接口层是必要的。

      3）可扩展以适应新类型的见解。 QuickInsights旨在轻松支持新的洞察类型。因此，我们将挖掘过程分为两部分：主题枚举和洞察的重要性评估，只有洞察评估模块负责注册新的洞察类型（第3.1.3节）。

      图3描绘了QuickInsights的整体工作流程。工作流程可分为三个阶段，“搜索和任务生成”（阶段1），“查询和评估”（阶段2）和“存储和细化”（阶段3）。前两个阶段在时间预算内以并行方式同时执行。一旦时间超过时间预算，在第3阶段进行细化，然后输出合格的见解。

在阶段1中，SubjectSearcher模块尝试枚举所有可能的子空间，每个子空间通过使用autoimpact模块来计算指定impact。然后，通过将每个子空间通过简单的洞察检查（通过功能依赖性检查器），生成洞察评估任务。生成的任务存储在优先级队列中，与更高影响相关的任务将被赋予更高的优先级。在阶段2中，任务由一组专用的工作线程并行计算。任务的计算包括三个步骤。首先，工作线程从队列中获取优先级最高的任务；然后根据任务参数对所有度量进行聚合，作为下一步执行数据查询，洞察评估作为最后一步进行。最后存储发现的洞察（即重要性超过某个阈值）。第一阶段和第二阶段都在时间预算内执行。

3.1.1最佳优先顺序

生成的任务存储在优先级队列中，我们将影响作为优先顺序来区分不同的任务。根据定义3，洞察得分对影响和重要性都是单调的，因此，在不知道重要性的情况下（由于洞察评估尚未完成），影响对于优先排序和修剪任务很有用。

3.1.2查询抽象

为了使QuickInsights可以移植到一般系统，需要一个抽象的查询接口层。表2显示了查询接口AggregationQuery，它在QuickInsights的挖掘层和数据存储之间建立连接。因此，只要底层数据存储提供AggregationQuery的实现，QuickInsights就是可移植的。通过我们的查询接口的查询在语义上等同于SQL查询：

“SELECT Aggr1(measure1), Aggr2(measure2), ... GROUP BY breakdownDimension where filter = subspace”。

请注意，QuickInsights的效率主要取决于底层查询引擎的效率。 Microsoft Power BI团队支持基于Analysis Service的查询API。为了通过利用数据局部性进一步提高查询性能，我们引入了预取机制并将上述GROUP BY子句修改为：

“GROUP BY expandingDimension，breakdownDimension”。

聚合结果打包到字典中。字典的每个项目都在expandingDimension中收集每个值的结果。将其设置为null将禁用预取。表3显示了两个典型的查询示例和相应的结果。

3.1.3可扩展性

QuickInsights旨在可扩展，以便轻松支持新类型的洞察。 QuickInsights的可扩展性在很大程度上依赖于洞察的统一定义（定义4）。具体而言，由于每个洞察主题被表述为{𝑠𝑢𝑏𝑠𝑝𝑎𝑐𝑒(𝑠),𝑏𝑟𝑒𝑎𝑘𝑑𝑜𝑤𝑛,𝑚𝑒𝑎𝑠𝑢𝑟𝑒(𝑠)}，因此洞察主题的聚合结果可以由公共数据结构表示，其可以被重用于任何新的洞察类型。

3.1.4修剪

如图3所示，我们应用了三个修剪标准（修剪1、2、3）来提高性能：修剪1会删除搜索空间的大部分，而修剪2和修剪3会降低洞察评估的成本。

删减1：我们删减任何影响小于给定阈值的洞察。影响低于临界值的洞察变得不那么重要，因此不那么有趣，因此我们采用修剪1来消除不重要的任务。此外，考虑到影响的反单调条件（引理1），任何子空间也可以安全地从主题搜索器模块中舍弃。在实现中，我们将阈值设置为0.01。

修剪2：对于每种洞察类型，我们使用一个大小为K的缓冲区来保留得分最高的洞察。考虑𝑠𝑐𝑜𝑟𝑒𝑡 =𝑖𝑚𝑝𝑎𝑐𝑡 ∙ 𝑠𝑖𝑔𝑛𝑖𝑓𝑖𝑐𝑎𝑛𝑐𝑒𝑡 < 𝑖𝑚𝑝𝑎𝑐𝑡（因为𝑠𝑖𝑔𝑛𝑖𝑓𝑖𝑐𝑎𝑛𝑐𝑒𝑡在0和1之间），因此，如果当前洞察的影响已经小于kth洞察的得分，则会保存其进一步的评估。此外，由于每个任务都知道需要评估哪些类型的洞察，如果洞察评估可以对所有需要的类型进行修剪，则可以保存数据查询并放弃任务。

修剪3：当兄弟组仅包含一个子空间时，进一步的洞察评估变得微不足道（因为该子空间与其父子空间相同，因此意味着重复），因此不需要。因此，在数据查询之后，如果兄弟组中只有一个项目，就避免了进一步的洞察评估。

3.2易于理解的见解消除

我们通过检测和消除由功能依赖（简称FD）引起的EII（即，易于理解的见解）来说明如何提高洞察质量。

3.2.1 FD诱导的EII

定义5（功能依赖）：函数依赖FD：X→Y意味着Y的值由X的值确定，其中X和Y是两列（即，维度或度量）。

FD是多维数据中的常见关系，例如，在表1中，国家→地区。 FD反映了某些层次结构或列间的一致关系。

定义6（洞察主题的FD）：我们选择出现在洞察主题中的所有列为𝑠𝐶𝑜𝑙{𝑠1，...，𝑠𝑝，𝑑，𝑚1，...，𝑚𝑞}，其中𝑠1~𝑠𝑝是子空间中出现的维度，𝑑是裂变维，𝑚1~𝑚𝑞是q的度量。如果∃𝑋⊂𝐶𝑜𝑙，𝑌⊂𝐶𝑜𝑙，𝑋∩𝑌=∅，𝑠.𝑡.𝑋→𝑌， 𝑋→𝑌 在洞察主题中是函数依赖FD。

 定义7（FD诱导的EII）：如果其集合值表现出预先确定的关系，那么洞察力被称为FD诱导的EII（或简称EII），从而为数据分析提供简单有用的信息。

 我们仔细检查在洞察主题中产生的所有可能的FD，并得出可诱导EII的五种形式的FD，如表4（ID1~ID5）所示。 ID1~5如何诱导EII的细节见附录。

3.2.2有效的FD检查

给定洞察候选者，我们需要检查是否存在满足表4中任何ID1~5的FD，从而避免进一步的洞察评估。 检查可以概括为确定是否保持。 另一方面，这种确定需要知道全局保存在给定数据集中的FD，并且这样的FD可以从数据模式获得或者可以使用诸如[13]的FD挖掘技术预先计算。 因此，我们将问题表述为：

问题1（检查功能依赖性）：给定一组FD {𝑋→𝑌}，...，{𝑋→𝑌}，检查是否保持{𝑑~𝑑}→𝑑。

这个问题可以通过在FD理论领域中利用两个公理来解决：反身性和传递性。 粗略地说，如果𝑑𝑗∈{𝑑1~𝑑𝑖}，{𝑑1~𝑑𝑖}→𝑑𝑗是真的（自反性）。 否则，找到 检查（传递性）。 此过程以递归方式重复，直到达到空集。

3.3 批查询和缓存

 数据查询占用了QuickInsights的大部分计算成本。接下来，我们将说明我们在查询优化方面的考虑和方法，以显着节省计算成本。

3.3.1缓存

如图3所示，Subject-Searcher模块，AutoImpact模块和Tasks发布数据查询。 Subject-Searcher使用查询来枚举子空间，AutoImpact需要影响度量的查询结果来为每个子空间分配影响，而Task发出查询以进行洞察力评估。这些模块将生成重复的查询，例如，查询{China}⊕Year可用于洞察力评估，而Subject-Searcher也需要用于搜索空间探索的结果子空间，并且通过聚合所有影响从AutoImpact获得所得子空间的影响 - 措施。因此，需要缓存机制，并且需要设计缓存单元以便于这些模块的需求，如图4所示。这里缓存单元是按分类分组的所有度量的二维聚合结果（两者都是洞察力测量和影响测量），每个缓存单元的相应查找键由𝑠𝑠⊕表示。这种粒度对于所有模块的需求是必要的。

3.3.2智能批处理

典型的多维数据集包含大量的𝑠𝑠⊕组合，并且需要大量的数据查询，这会导致显着的性能影响。另一方面，通过检查来自QuickInsights的已发布查询，我们发现生成的子空间彼此之间表现出强大的关系，这提供了减少查询数量的机会。

定义9（二级兄弟组）。如果一个子空间可以由一个二级组生成，则它们形成一个二级兄弟组：𝑠⊕𝐷1⊕𝐷2。

例如，当我们有以下三个查询请求时：{China}⊕Year，{USA}⊕Year，{India}⊕Year，他们可以被一个二级组覆盖 ：  {*}⊕Country⊕Year，因此，相应的子空间属于2级兄弟组。将这三个查询一起批处理将利用数据中多个相关查询的空间局部性，从而提高查询性能。

但是，批处理会产生一个问题：更高级别的分组会引入可能永远不会使用的其他聚合结果。在上面提到的例子中，{*}⊕Country⊕Year获得了三个请求的必要结果，但它也获得了除中国，美国和印度之外的所有国家的结果。此外，考虑到QuickInsights通常在时间预算内运行，因此只能检查整个搜索空间的一部分。因此，我们倾向于在开始时按需进行批量查询而不是详尽的预取，以减轻查询无用结果的问题。

如表2所示，QuickInsights的查询API将扩展维度视为用于批处理的附加组。我们注意到，使用最新细分作为扩展维度可以充分利用空间局部性，并且预取结果也可以有效地用于后续任务。

从另一个角度来看，列基数和pruning1将影响批量查询的效用。例如，如果City for {China}中有> 1000个不同的值，则通过在City上展开的批量查询生成1000个子空间，但由于Pigeonhole原则，最多100个子空间的影响> 0.01，因此大多数（> 90％）预取的子空间是无用的，这使得这个查询非常无效。因此，当细分产生的子空间数超过阈值时，我们不会将其用于扩展维度。

通过这些考虑，我们将我们的方法命名为智能批处理。该方法旨在减少数据查询的数量，同时有效地利用预取的结果。考虑到页面限制，我们将示例，QuickInsights的查询逻辑的伪代码与缓存和智能批处理放在附录中。

4.评估

我们定量评估QuickInsights在真实数据集上的有效性和效率（第4.1节）。我们通过分别针对专家用户和非专家用户的两项用户研究，进一步评估QuickInsights在协助数据分析方面的有用性（第4.2节）。

4.1 评估真实数据集

4.1.1设置数据集。

我们在447个真实数据集上评估QuickInsights。这些多维数据集是在与Microsoft团队合作的帮助下收集的。这些数据集涵盖了各个领域，如销售，天气，市场，医疗保健等。它们的规模非常不同，大小从8.8KB到386.2MB不等，维度从几十到几百不等。一些数据集可在我们的网站上找到[26]。

环境。所有实验均在配备3.6GHz Intel Core i7-4790处理器和16GB RAM的机器上进行。 QuickInsights部署在SQL Server Analysis Service（SQL Server 2016 RTM，版本：13.0.1601.5，表格模式）上。

组态。我们按如下方式设置QuickInsights的配置：#worker threads = 8; 探索子空间的最大维数= 2，因为具有高维度子空间的输出见解对于常见用法的信息量较少;为简单起见，我们将COUNT设置为所有数据集的影响度量，因为设置不同的影响度量对效率评估几乎没有影响。

4.1.2设计

我们的目标是从三个方面评估QuickInsights：整体有效性，消除EII的有效性和挖掘效率。

4.1.3结果

以下是我们的实验结果。

整体效果的结果。图5顶部的曲线显示了在不同时间预算中挖掘的“好”洞察（即黄金集合洞察）的覆盖范围。每个数据点是总共447个数据集的覆盖率的平均值。覆盖范围随着更多时间预算的增加而增加，这是合理的，因为可以探索和评估更多的搜索空间，可以发现更难以找到的洞察力。此外，覆盖范围从0.6到0.8。例如，当时间预算设置为5秒时，覆盖率为0.63，这表明即使响应时间非常快，QuickInsights返回的超过60％的见解也是真正得分最高的。

FD检查程序启用与禁用的结果。表5描述了禁用FD检查器时的输出见解的平均覆盖范围（第三行）和EII的比率（第四行）。由于此评估是在具有FD作为输入的218个数据集上进行的，因此我们还列出了启用FD（第二行）时的相应覆盖率以进行比较。如表5所示，当FD检查器被禁用时，良好见解的覆盖率一致下降约3％。此外，当FD检查器被禁用时，𝑓𝑝_𝐹𝐷（𝑡）的值约为25％，即，当用户检查输出见解时，将容易推断出四分之一。因此，禁用FD检查器将显着降低QuickInsights的用户体验。

启用最佳优先级的结果与禁用的优先级优先级的结果。如图5所示，底部曲线显示了禁用最佳优先级优先级时的良好见解的覆盖范围。与顶部曲线（启用最佳优先级优先级）相比，我们可以看到最佳优先级优先级的获得是显着的。如果没有这样的机制，洞察挖掘程序似乎陷入大量无价值的搜索空间，使得曲线相当平坦。要将覆盖率提高到63％左右，它需要的时间远远超过25秒，而如果启用了最佳优先级，则仅在5秒内实现相同的覆盖率。我们可以看到，使用最佳优先级优先级的性能提升是巨大的。

启用智能批处理与禁用的结果。如图5所示，中间曲线显示了禁用智能批处理时的良好见解的覆盖范围。与顶部曲线（启用智能批处理）相比，智能批处理可使覆盖率增加约10％。从性能角度来看，当禁用智能批处理时，需要大约15秒才能达到63％的覆盖率（图5中的虚线），这比启用智能批处理时慢大约三倍。

表6说明了具有不同时间预算的缓存利用率，这反映了在进一步的洞察评估中重复使用了多少预取查询。 我们可以看到利用率相对稳定在40％。 该比率受近似超时批处理查询的影响，这些查询会生成大量未使用的缓存项。

附：

https://www.microsoft.com/en-us/research/project/quickinsights/

