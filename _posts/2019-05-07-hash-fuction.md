---
layout: post
title: "散列/哈希函数"
subtitle: ""
author: "Aili"
header-style: text
catalog: true
tags:
  - 函数
  - 密码
---

## 什么是哈希 

散列（英语：Hashing）是计算机科学中一种对数据的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。

> 哈希函数就是一种映射，是从关键字到存储地址的映射。


## 应用 

* 密码学： MD5，SHA-256
* 数据结构： 


## 特征 

* 输入长度可以是任意长度
* 输出是固定长度
* 给出任意的报文可以很轻松的算出哈希函数H（x）
* 哈希函数是个不可逆的函数，就是给出一个Y，其中Y=H（x）,你完全不能通过Y去推算出x
* 哈希函数不存在碰撞，就是不存在任意一个x′,使H（x′）=H（x）



### Hash算法是如何实现的？
密码学和信息安全发展到现在，各种加密算法和散列算法已经不是只言片语所能解释得了的。在这里我们仅提供几个简单的概念供大家参考。
作为散列算法，首要的功能就是要使用一种算法把原有的体积很大的文件信息用若干个字符来记录，还要保证每一个字节都会对最终结果产生影响。那么大家也许已经想到了，求模这种算法就能满足我们的需要。
事实上，求模算法作为一种不可逆的计算方法，已经成为了整个现代密码学的根基。只要是涉及到计算机安全和加密的领域，都会有模计算的身影。散列算法也并不例外，一种最原始的散列算法就是单纯地选择一个数进行模运算，比如以下程序。
```python
#  构造散列函数
def hash(a):
    return a % 8

#  测试散列函数功能

print(hash(233))
print(hash(234))
print(hash(235))

# 输出结果
- 1
- 2
- 3
```

很显然，上述的程序完成了一个散列算法所应当实现的初级目标：用较少的文本量代表很长的内容（求模之后的数字肯定小于8）。但也许你已经注意到了，单纯使用求模算法计算之后的结果带有明显的规律性，这种规律将导致算法将能难保证不可逆性。所以我们将使用另外一种手段，那就是异或。
再来看下面一段程序，我们在散列函数中加入一个异或过程。

```python
#  构造散列函数
def hash(a):
    return (a % 8) ^ 5

#  测试散列函数功能
print(hash(233))
print(hash(234))
print(hash(235))

# 输出结果
- 4
- 7
- 6
```



很明显的，加入一层异或过程之后，计算之后的结果规律性就不是那么明显了。
当然，大家也许会觉得这样的算法依旧很不安全，如果用户使用连续变化的一系列文本与计算结果相比对，就很有可能找到算法所包含的规律。但是我们还有其他的办法。比如在进行计算之前对原始文本进行修改，或是加入额外的运算过程（如移位），比如以下程序。

```python
#  构造散列函数
def hash(a):
    return (a + 2 + (a << 1)) % 8 ^ 5

#  测试散列函数功能
print(hash(233))
print(hash(234))
print(hash(235))

# 输出结果
- 0
- 5
- 6
```

这样处理得到的散列算法就很难发现其内部规律，也就是说，我们并不能很轻易地给出一个数，让它经过上述散列函数运算之后的结果等于4——除非我们去穷举测试。
上面的算法是不是很简单？事实上，下面我们即将介绍的常用算法MD5和SHA1，其本质算法就是这么简单，只不过会加入更多的循环和计算，来加强散列函数的可靠性。


## 常见的Hash函数有以下几个：

* 直接定址法：直接以关键字k或者k加上某个常数（k+c）作为哈希地址。
* 数字分析法：提取关键字中取值比较均匀的数字作为哈希地址。
* 除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得余数作为哈希表地址。
* 分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址。
* 平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求取中间的几位作为哈希地址。
* 伪随机数法：采用一个伪随机数当作哈希函数。

### 冲突的解决
上面介绍过碰撞。衡量一个哈希函数的好坏的重要指标就是发生碰撞的概率以及发生碰撞的解决方案。任何哈希函数基本都无法彻底避免碰撞，常见的解决碰撞的方法有以下几种：

* 开放定址法：
开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。
* 链地址法
将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。
* 再哈希法
当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。
* 建立公共溢出区
将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。


#### 开放定址法

比较经典的有线性探测方法（Linear Probing）、二次探测（Quadratic probing）和 双重散列（Double hashing）等方法。
##### 线性探测方法
当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 4 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是按顺序地往后一个一个找，看有没有空闲的位置，此时，运气很好正巧在下一个位置就有空闲位置，将其插入，完成了数据存储。线性探测法一个很大的弊端就是当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，需要从头到尾探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。
##### 二次探测方法
二次探测是二次方探测法的简称。顾名思义，使用二次探测进行探测的步长变成了原来的“二次方”，也就是说，它探测的下标序列为 hash(key)+0，hash(key)+1^2或[hash(key)-1^2]，hash(key)+2^2或[hash(key)-2^2]。
以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 7 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。按照二次探测方法的操作，有冲突就先 + 1^2，8 这个位置有值，冲突；变为 - 1^2，6 这个位置有值，还是有冲突；于是 - 2^2， 3 这个位置是空闲的，插入。
##### 双重散列方法
所谓双重散列，意思就是不仅要使用一个散列函数，而是使用一组散列函数 hash1(key)，hash2(key)，hash3(key)。。。。。。先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。
以上图为例，散列表的大小为 8 ，黄色区域表示空闲位置，橙色区域表示已经存储了数据。目前散列表中已经存储了 7 个元素。此时元素 7777777  经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。此时，再将数据进行一次哈希算法处理，经过另外的 Hash 算法之后，被散列到位置下标为 3 的位置，完成操作。事实上，不管采用哪种探测方法，只要当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，需要尽可能保证散列表中有一定比例的空闲槽位。

一般使用加载因子（load factor）来表示空位的多少。加载因子是表示 Hsah 表中元素的填满的程度，若加载因子越大，则填满的元素越多,这样的好处是：空间利用率高了,但冲突的机会加大了。反之,加载因子越小,填满的元素越少,好处是冲突的机会减小了，但空间浪费多了。


#### 链地址法



## 哈希函数  


算法名称	| 输出大小（bits）|内部大小|区块大小	|长度大小|字符尺寸|碰撞情形|
| :----: |:----: |:----: |:----: |:----: |:----: |:----: |
|HAVAL|256/224/192/160/128	|256	|1024	|64	|32|	是|
|MD2|	128	|384	|128|	No	|8	|大多数|
|MD4|128|	128	|512|	64	|32|	是|
|MD5|128	|128|	512	|64 |32|	是|
|PANAMA|256	|8736|256|	否	|32|	是|
|RadioGatún|Arbitrarily long|58 words|3 words|否|	1-64|	否|
|RIPEMD|	128	|128|	512	|64	|32	|是|
RIPEMD-128/256|	128/256	|128/256	|512	|64|	32|	否|
|RIPEMD-160/320	|160/320	|160/320|	512	|64	|32	|否|
|SHA-0|160|	160	|512|	64|	32|	是|
|SHA-1|	160|	160	|512	|64	|32	|有缺陷|
|SHA-256/224|	256/224	|256|	512	|64|	32|	否|
|SHA-512/384	|512/384|	512|	1024|	128	|64|	否|
|Tiger(2)|192/160/128|	192	|512|	64|	64|	否|
|WHIRLPOOL	|512	|512|	512|	256|	8	|否|



**"Welcome to the producer side!"**
